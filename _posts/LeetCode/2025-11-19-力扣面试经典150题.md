---
layout:       post
title:        "LeetCode面试经典150题刷题笔记"
date:         2025-11-19 14:08
author:       "rz"
header-style: text
catalog:      true
mathjax: true
tags:
    - LeetCode
    - Python
    - 数据结构
    - 算法
    - 面试
---

## 88.合并两个有序数组

- Date: 2025-11-19
- Level：简单

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 ```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9 <= nums1[i], nums2[j] <= 10^9
 

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

### 我的解法

这个题类似于数组的原址排序。所以主要思路分为先大后小排序还是先小后大排序。先小后大的话，会存在一个元素被多次重新防止的问题，而先大后小则不存在这个问题。

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        ptr1 = m-1
        ptr2 = n-1
        for i in range(m+n-1, -1, -1):
            if ptr1 < 0:
                nums1[i] = nums2[ptr2]
                ptr2 -= 1
            elif ptr2 < 0:
                break
            else:
                if nums1[ptr1]>=nums2[ptr2]:
                    nums1[i] = nums1[ptr1]
                    ptr1 -= 1
                else:
                    nums1[i] = nums2[ptr2]
                    ptr2 -= 1
```

提交结果如下。

![](/img/in-post/leetcode/classical-150/88-res.png)


## 27.移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。

假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
返回 k。
用户评测：

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 通过。

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```


**提示：**

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100

### 我的解法

是一个原址操作数组的问题，需要把值不等于val的放在前面，并统计个数，后面的结果不用管。也需要本着尽可能少地交换次数的原则，可以设置前后两个指针，分别从此前往后遍历和从后往前遍历，如果前面遇到值为val的元素就让它和后指针遇到的值不为val的元素交换（由于结果中不关心数组后面的部分，所以其实只需要将后指针的数复制到前指针的位置），直到两个指针碰头。
需要注意的是边界条件的设置，具体Python代码实现如下：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if len(nums)==0:
            return 0
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[left]==val:
                while right >= left:
                    if nums[right]==val:
                        right -= 1
                    else:
                        nums[left] = nums[right]
                        right -= 1
                        left += 1
                        break
            else:
                left += 1

        if left >= len(nums):
            return len(nums)
        return max(0, left)

```

提交结果如下

![](/img/in-post/leetcode/classical-150/27-res.png)

## 26. 删除有序数组中的重复项

- Date: 2025-11-19
- Level: 简单

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。

nums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。

判题标准:

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 通过。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 104
- -100 <= nums[i] <= 100
- nums 已按 非递减 顺序排列。

### 我的解法

这道题中已经说明要处理的数组是按照非递减顺序排好序的，也就是后一个元素肯定不小于前一个元素，并且要求处理后的数组前 k 个元素也是非递减顺序的，也就是递增的（因为已经去重）。这时候就不适合用两个指针分别从头到尾和从尾到头处理了。但也可以用两个指针来处理，一个慢指针和一个快指针。慢指针 ptr1 负责保证其之前的元素都是已经去重的，快指针负责寻找下一个未出现过的数。具体的Python实现代码如下：


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)<=1:
            return len(nums)
        ptr1 = 0
        ptr2 = 1
        while ptr2<len(nums):
            if nums[ptr1] <= nums[ptr2]:
                while ptr2<len(nums) and nums[ptr2]<=nums[ptr1]:
                    ptr2 += 1
                if ptr2 == len(nums):
                    return ptr1 + 1
                nums[ptr1+1] = nums[ptr2]
            ptr1 += 1
            ptr2 += 1
        return ptr1 + 1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/26-res.png)

可以看到时间复杂度并不是最优的。这是因为题目里还有条件我们没有利用上。即数组元素的取值只有201个，但数组的长度却可能长达30000，其实只要慢指针到达了200之后，就不用继续往下判断了。为了更进一步，我们可以在外层的 while 循环中加上一个小的终止条件，在LeetCode中的时间复杂度就可以达到最优了。

```python
if ptr1 == 200:
    return 201
```

![](/img/in-post/leetcode/classical-150/26-res2.png)

## 80. 删除有序数组中的重复项II

- Date: 2025-11-19
- Level: 中等

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
 ```

**示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 10^4
- -10^4 <= nums[i] <= 10^4
- nums 已按升序排列

### 我的解法

一种最容易想到的笨方法是搞三个指针，第一个指针标记当前已经处理好的符合题目要求的前缀长度，另外两个指针用来标记一个滑动窗口，根据滑动窗口的大小来确定前缀子数组需要增长1个还是2个。这种思路的时间复杂度为 ``O(n)``，空间复杂度主要是三个指针，以及一些循环变量，是 ``O(1)`` 的，算是符合题目的要求。具体Python实现代码如下

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ptr1 = 0  # 标记已排序位置
        left = 0  # 窗口左指针
        right = 1  # 窗口右指针
        while right < len(nums):
            while right<len(nums) and nums[left] == nums[right]:
                right += 1
            if right - left > 1:
                nums[ptr1] = nums[left]
                nums[ptr1+1] = nums[left]
                ptr1 += 2
            else:
                nums[ptr1] = nums[left]
                ptr1 += 1
            left = right
            right += 1
        if nums[len(nums)-1] != nums[len(nums)-2]:
            nums[ptr1] = nums[len(nums)-1]
            ptr1 += 1
        return ptr1
```

在LeetCode上的提交结果如下

![](/img/in-post/leetcode/classical-150/80-res.png)

时间复杂度排名比较落后，看来还能削减一半

## 169. 多数元素

- Date: 2025-11-19
- Level: 简单

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**
```
输入：nums = [2,2,1,1,1,2,2]
输出：2
 ```

**提示：**
- n == nums.length
- 1 <= n <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9
- 输入保证数组中一定有一个多数元素。

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

### 我的解法

最简单的方法就是暴力方法，直接统计每个元素出现的个数，然后挑出多数元素。时间复杂度为 ``O(n)``，空间复杂度也是 ``O(n)``，代码如下

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        max_count = 0
        nums_count = {}
        for x in nums:
            if x in nums_count:
                nums_count[x] += 1
            else:
                nums_count[x] = 1
            if max_count < nums_count[x]:
                max_count = nums_count[x]
                if max_count >= (len(nums)+1)//2:
                    return x
        # 确定存在多数数的情况下，其实不会走到
        return 0
```

提交结果如下，排名确实不咋地

![](/img/in-post/leetcode/classical-150/169-res.png)

### 更优解法

更优的解法是基于一个发现：如果在数组的一个前缀中存在一个元素出现的次数占前缀的一半，那么数组剩余部分中的多数元素与整个数组的多数元素是相同的。这个可以通过比较简单的方法来证明。
基于这个发现，我们就可以实现一种空间复杂度更低的方法，时间复杂度也是 ``O(n)``，但是系数会低一些。

具体Python代码实现如下

```python
    def majorityElement0(self, nums: List[int]) -> int:
        label = nums[0]
        count = 1
        for i in range(1, len(nums)):
            if nums[i]==label:
                count += 1
            else:
                count -= 1
            if count == 0 :
                label = nums[i]
                count = 1
        return label
```

提交结果如下

![](/img/in-post/leetcode/classical-150/169-res-2.png)

## 189.轮转数组

- Date: 2025-11-20
- Level: 中等

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

**示例 1:**
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
 ```

**提示：**

- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1
- 0 <= k <= 10^5
 

**进阶：**

- 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

### 我的解法一

最容易想到的方法就是直接重新拼接一个数组，只是需要注意的是这道题要求对数组的原址进行修改，所以暴力的解法如下，时间复杂度为 ``O(n)``， 空间复杂度也是 ``O(n)``。

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n <= 1:
            return
        k = k % n
        if k == 0:
            return
        
        nums1 = nums[-k:]
        nums2 = nums[:-k]
        nums[:k] = nums1
        nums[k:] = nums2
        return 
```

提交结果如下

![](/img/in-post/leetcode/classical-150/189-res.png)

虽然时间复杂度在提交排名中最优，但这道题的考察点应该是对空间复杂度的优化上。

### 我的解法二

题目中提示我们能否想出一种空间复杂度为 ``O(1)`` 的方法，我们来尝试一下。可以观察一下轮转的规律，很容易得到一个基于元素当前位置去计算轮转后元素位置的计算公式。
$$
i' = (i+k) \text{mod} n
$$

其中，$ i $ 为元素在数组中当前的位置，$ k $ 为轮转步数， $ i' $ 为该数组轮转后的新位置， $ n $ 为数组长度。
通过观察可以发现，在整个数组完整轮转完之前，一个元素的轮转只会影响另一个尚未参加轮转的元素。基于此我们就可以通过一个跳跃遍历来完成对整个数组的更新，所需要的额外空间只是一个指针和一个记录当前值的缓存，空间复杂度为 ``O(1)``

**有Bug**

## 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。


**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 105
- 0 <= prices[i] <= 104

### 我的解法

首先容易想到的是填表的方法，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                matrix[i][j] = max(current, matrix[i][j-1], matrix[i+1][j])
        return matrix[0][n-1]
```
但在系统提交后显示内存超出限制，接下来需要对内存使用进行优化。上面这个代码的空间复杂度是 ``O(n^2)``的，实际上表（矩阵）中的每个元素我们只用了一次，所以可以继续优化，每次只保留当前步长，以及上一步长的结果，这样可以使空间复杂度降到 ``O(n)``，具体代码实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        profits = [0 for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                current_profit = max(profits[i], profits[i+1], current)
                profits[i] = current_profit
        return profits[0]
```

这次有时间超限制了，212个测试样例通过了198个。

### 官方题解

看了官方题解之后，是自己傻了，只需要遍历一次数组即可，时间复杂度 ``O(n)``，空间复杂度 ``O(1)``，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/121-res.png)

## 122. 买卖股票的最佳时机

- Date: 2025-11-22
- Level: 中等

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 你能获得的 最大 利润 。

 
**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 3 * 10^4
- 0 <= prices[i] <= 10^4

### 我的解法

利用动态规划解法，从第 i 天到第 j 天的最大收益为

$$
\text{profit}(i, j) = \text{max}(\text{profit}(i+1, j)+\text{profit}(i, j-1)-\text{profit}(i+1, j-1), \text{price}(j)-\text{price}(i))
$$

可以写出Python代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        n = len(prices)
        profits = [[0 for _ in range(n)] for __ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j >= n:
                    break
                profits[i][j] = max(profits[i][j-1]+profits[i+1][j]-profits[i+1][j-1], prices[j]-prices[i])
        return profits[0][n-1]      
```

提交后提示超出内存限制。其实不必保存整个利润数组

其实不必这么复杂，只要有利润就加进来即可，时间复杂度为 $ O(n) $，具体Python实现代码如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        profit = 0
        for i in range(0, len(prices)-1):
            profit += max(0, prices[i+1]-prices[i])
        return profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/122-res.png)

## 55. 跳跃游戏

- Date：2025-11-24
- Level: 中等

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
 ```

**提示：**

- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 10^5

### 我的解法

这道题最容易想到的做法就是用广度优先搜索或深度优先搜索，以下是使用广度优先搜索的Python实现

```python
from collections import deque
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        queue_list = deque()
        queue_list.append(0)
        
        while len(queue_list)>0:
            current = queue_list.popleft()
            if current == len(nums)-1:
                return True
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in queue_list)):
                    queue_list.append(current+i)
        if len(nums)-1 in arrived_pos:
            return True
        return False
```

但提交后显示运行超时。我们重新检查代码，感觉 ``((current+i) in queue_list)`` 这个在双向队列中判断元素是否存在的过程耗时较大，我们可以将其替换为hashset来节省时间，修改后的代码如下

```python

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        arriving_pos = set()
        arriving_pos.add(0)
        
        while len(arriving_pos)>0:
            current = arriving_pos.pop()
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in arriving_pos)):
                    if current + i == len(nums)-1:
                        return True
                    arriving_pos.add(current+i)
        return False

```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res.png)

这个方案的时间效率仍然是比较垫底的。

### 官方解法

看了官方解法之后感觉自己好蠢。这道题直接用贪心方法即可

对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。

Python 代码如下

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        
        max_pos = nums[0]
        if max_pos >= len(nums)-1:
            return True
        for i in range(0, len(nums)):
            if i > max_pos:
                return False
            max_pos = max(max_pos, i + nums[i])
            if max_pos >= len(nums)-1:
                return True

        return False
```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res2.png)

## 45. 跳跃游戏II

- Date： 2025-11-24
- Level: 中等

给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：

0 <= j <= nums[i] 且
i + j < n
返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。

 

**示例 1:**
```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**
```
输入: nums = [2,3,0,1,4]
输出: 2
 ```

**提示:**

- 1 <= nums.length <= 104
- 0 <= nums[i] <= 1000
- 题目保证可以到达 n - 1

### 我的解法

仍然可以用贪心的方法，计算每一步最远能走到哪里，只是需要注意一些边界判断的细节，Python代码实现如下

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums)==1:
            return 0
        if nums[0]>= len(nums)-1:
            return 1
        step = 1
        max_list = [0]
        max_list.append(nums[0])
        while True:
            max_list.append(0)
            for i in range(max_list[step-1], max_list[step]+1):
                max_list[step+1] = max(max_list[step+1], i+nums[i])
                if max_list[step+1]>=len(nums)-1:
                    return step+1
            step += 1
            if step > len(nums):
                return -1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/45-res.png)

## 274. H指数

- Date: 2025-11-24
- Level: 中等

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。

根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**示例 2：**
```
输入：citations = [1,3,1]
输出：1
 ```

**提示：**

- n == citations.length
- 1 <= n <= 5000
- 0 <= citations[i] <= 1000
 
### 我的解法

一种容易想到的方法就是先排序，将数组按照从小到大的顺序排好之后从左到右逐步判断，同时从 n 到 0 逐渐降低H指数。这样时间复杂度主要是在排序阶段，为 $ O(n\text{log}n) $，具体代码实现如下

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        self.quick_sort(citations)
        print('citations = ', citations)
        n = len(citations)
        for i in range(0, n):
            if citations[i]>=n-i:
                return n-i
        return 0

    def quick_sort(self, arr: List):
        if len(arr) <= 1:
            return
        self.quick_sort_partation(arr, 0, len(arr) - 1)

    def quick_sort_partation(self, arr: List[int], left: int, right: int):
        if right - left <= 0:
            return
        ptr1 = left - 1
        for ptr2 in range(left, right):
            if arr[ptr2] <= arr[right]:
                ptr1 += 1
                temp = arr[ptr1]
                arr[ptr1] = arr[ptr2]
                arr[ptr2] = temp
        temp = arr[ptr1 + 1]
        arr[ptr1 + 1] = arr[right]
        arr[right] = temp
        self.quick_sort_partation(arr, left, ptr1)
        self.quick_sort_partation(arr, ptr1 + 2, right)
```

提交结果如下

![](/img/in-post/leetcode/classical-150/274-res.png)

其实有时候不必手搓快排，看面试时要求即可，可以直接使用 ``sorted`` 方法。

## 238. 除自身以外的数组乘积

- Date: 2025-11-26
- Level: 中等

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

 
**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
 ```

**提示：**

- 2 <= nums.length <= 10^5
- -30 <= nums[i] <= 30
- 输入 保证 数组 answer[i] 在  32 位 整数范围内

### 解法

这道题的主要难点在于不能使用除法，一开始确实没有想到好的方法。直到看了官方的题解，大呼自己愚蠢。其实可以两次遍历数组即可，第一次计算每个位置的左侧所有元素的乘积，第二次计算每个位置右侧所有元素的乘积，然后二者相乘即可得到答案，时间复杂度为 ``O(n)``，Python代码实现如下

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        answer = [1]
        for i in range(1, len(nums)):
            answer.append(answer[-1]*nums[i-1])  # 计算左边的乘积
        right = 1
        for i in range(len(nums)-2, -1, -1):
            right *= nums[i+1]
            answer[i] *= right
        return answer
        
```

提交结果如下

![](/img/in-post/leetcode/classical-150/238-res.png)

## 134. 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
 ```

**提示:**

- n == gas.length == cost.length
- 1 <= n <= 10^5
- 0 <= gas[i], cost[i] <= 10^4
- 输入保证答案唯一。


### 我的解法

首先想到的是暴力解法，根据每个加油站的油量以及到达下一个加油站所需的油量，可以计算出从这个加油站出发到达下一个加油站的净油增量，我们只能从某个净油增量不为负的加油站出发。如此可以写出暴力的解法，时间复杂度为 ``O(n^2)``

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        res = []
        n = len(gas)
        for i in range(0, n):
            res.append(gas[i]-cost[i])
        for i in range(0, n):
            if res[i]>=0:
                s = 0
                flag = True
                for j in range(i, n):
                    s += res[j]
                    if s < 0:
                        flag = False
                        break
                if flag:
                    for j in range(0, j):
                        s += res[j]
                        if s < 0:
                            flag = False
                            break
                if flag:
                    return i
        return -1     
```
不出所料，运行超时

### 贪心解法

看了，网友的题解才明白这道题可以用贪心的方法来做：

x能到达y但不能到达y+1，实际上说明了：x与y之间的任意一个点（设为k）的不可能比x还“富裕”，因为x能到达k，则一定说明x到达k的时候一定油量是有余或者刚好的，不能是亏欠的；那么如果x都到达不了，“白手起家”的k就更不可能了。

这样就可以只遍历一次数组即可得到答案，总的时间复杂度为 O(n) 。Python代码如下

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        start = 0
        s = 0
        i = 0
        while i < start + n:
            if start >= n:
                return -1
            j = i % n
            s += gas[j] - cost[j]
            if s<0:
                start = i+1
                s = 0
            i += 1
            
        return start
```

提交结果如下

![](/img/in-post/leetcode/classical-150/134-res.png)


## 42. 接雨水

- Date: 2025-11-25
- Level: 困难

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](/img/in-post/leetcode/classical-150/42-question.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
 ```

**提示：**

- n == height.length
- 1 <= n <= 2 * 10^4
- 0 <= height[i] <= 10^5

### 我的解法

可以观察题目中给出的示意图，能盛水的凹槽一定会有两个边，左边的边和右边的边。这两个边一定是其所在局部的局部最高点，即左边所在位置向右移一步会降低，右边所在的位置向左移一步会降低。我们写一个函数分别找出数组的某个范围内左边第一个凹槽的左边和右边第一个凹槽的右边是比较容易的。找出这两个边之后，我们只需要判断哪个边矮，然后优先去处理哪个凹槽，更新剩余范围内的下一个边就可以了。这样总的时间复杂度就是 $ O(n) $ 的，因为只需要遍历一遍数组。具体Python代码实现如下

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n<=2:
            return 0
        total_water = 0

        # 从左边寻找第一个高点
        start_index = self.find_left_edge(height, 0, n-1)
        # 从右边寻找第一个高点
        end_index = self.find_right_edge(height, 0, n-1)
        if start_index==-1 or end_index==-1 or start_index >= end_index:
            return 0

        left = start_index
        right = end_index
        while left < right:
            if height[left] <= height[right]:
                # 先看左边的
                next_left_index = left + 1
                while next_left_index<=right and height[next_left_index]<height[left]:
                    total_water += height[left] - height[next_left_index]
                    next_left_index += 1
                left = self.find_left_edge(height, next_left_index, right)
                if left == -1:
                    break
            else:
                # 先看最右边的
                next_right_index = right - 1
                while next_right_index>=left and height[next_right_index]<height[right]:
                    total_water += height[right] - height[next_right_index]
                    next_right_index -= 1
                right = self.find_right_edge(height, left, next_right_index)
                if right == -1:
                    break
        return total_water

    # 在start_index到end_index范围内寻找能盛水的左边
    def find_left_edge(self, height: List[int], start_index, end_index):
        if start_index == end_index:
            return -1
        for i in range(start_index, end_index):
            if height[i] > height[i+1]:
                return i
        return -1

    # 在start_index到end_index的范围内从右到左寻找能盛水的右边
    def find_right_edge(self, height: List[int], start_index, end_index):
        if start_index == end_index:
            return -1
        for i in range(end_index, start_index, -1):
            if height[i] > height[i-1]:
                return i
        return -1

```

提交后的结果如下

![](/img/in-post/leetcode/classical-150/42-res.png)