---
layout:       post
title:        "LeetCode面试经典150题刷题笔记"
date:         2025-11-19 14:08
author:       "rz"
header-style: text
catalog:      true
mathjax: true
tags:
    - LeetCode
    - Python
    - 数据结构
    - 算法
    - 面试
---

## 88.合并两个有序数组

- Date: 2025-11-19
- Level：简单

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 ```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9 <= nums1[i], nums2[j] <= 10^9
 

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

### 我的解法

这个题类似于数组的原址排序。所以主要思路分为先大后小排序还是先小后大排序。先小后大的话，会存在一个元素被多次重新防止的问题，而先大后小则不存在这个问题。

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        ptr1 = m-1
        ptr2 = n-1
        for i in range(m+n-1, -1, -1):
            if ptr1 < 0:
                nums1[i] = nums2[ptr2]
                ptr2 -= 1
            elif ptr2 < 0:
                break
            else:
                if nums1[ptr1]>=nums2[ptr2]:
                    nums1[i] = nums1[ptr1]
                    ptr1 -= 1
                else:
                    nums1[i] = nums2[ptr2]
                    ptr2 -= 1
```

提交结果如下。

![](/img/in-post/leetcode/classical-150/88-res.png)


## 27.移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。

假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
返回 k。
用户评测：

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 通过。

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```


**提示：**

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100

### 我的解法

是一个原址操作数组的问题，需要把值不等于val的放在前面，并统计个数，后面的结果不用管。也需要本着尽可能少地交换次数的原则，可以设置前后两个指针，分别从此前往后遍历和从后往前遍历，如果前面遇到值为val的元素就让它和后指针遇到的值不为val的元素交换（由于结果中不关心数组后面的部分，所以其实只需要将后指针的数复制到前指针的位置），直到两个指针碰头。
需要注意的是边界条件的设置，具体Python代码实现如下：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if len(nums)==0:
            return 0
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[left]==val:
                while right >= left:
                    if nums[right]==val:
                        right -= 1
                    else:
                        nums[left] = nums[right]
                        right -= 1
                        left += 1
                        break
            else:
                left += 1

        if left >= len(nums):
            return len(nums)
        return max(0, left)

```

提交结果如下

![](/img/in-post/leetcode/classical-150/27-res.png)

## 26. 删除有序数组中的重复项

- Date: 2025-11-19
- Level: 简单

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。

nums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。

判题标准:

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 通过。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 104
- -100 <= nums[i] <= 100
- nums 已按 非递减 顺序排列。

### 我的解法

这道题中已经说明要处理的数组是按照非递减顺序排好序的，也就是后一个元素肯定不小于前一个元素，并且要求处理后的数组前 k 个元素也是非递减顺序的，也就是递增的（因为已经去重）。这时候就不适合用两个指针分别从头到尾和从尾到头处理了。但也可以用两个指针来处理，一个慢指针和一个快指针。慢指针 ptr1 负责保证其之前的元素都是已经去重的，快指针负责寻找下一个未出现过的数。具体的Python实现代码如下：


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)<=1:
            return len(nums)
        ptr1 = 0
        ptr2 = 1
        while ptr2<len(nums):
            if nums[ptr1] <= nums[ptr2]:
                while ptr2<len(nums) and nums[ptr2]<=nums[ptr1]:
                    ptr2 += 1
                if ptr2 == len(nums):
                    return ptr1 + 1
                nums[ptr1+1] = nums[ptr2]
            ptr1 += 1
            ptr2 += 1
        return ptr1 + 1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/26-res.png)

可以看到时间复杂度并不是最优的。这是因为题目里还有条件我们没有利用上。即数组元素的取值只有201个，但数组的长度却可能长达30000，其实只要慢指针到达了200之后，就不用继续往下判断了。为了更进一步，我们可以在外层的 while 循环中加上一个小的终止条件，在LeetCode中的时间复杂度就可以达到最优了。

```python
if ptr1 == 200:
    return 201
```

![](/img/in-post/leetcode/classical-150/26-res2.png)

## 80. 删除有序数组中的重复项II

- Date: 2025-11-19
- Level: 中等

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
 ```

**示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 10^4
- -10^4 <= nums[i] <= 10^4
- nums 已按升序排列

### 我的解法

一种最容易想到的笨方法是搞三个指针，第一个指针标记当前已经处理好的符合题目要求的前缀长度，另外两个指针用来标记一个滑动窗口，根据滑动窗口的大小来确定前缀子数组需要增长1个还是2个。这种思路的时间复杂度为 ``O(n)``，空间复杂度主要是三个指针，以及一些循环变量，是 ``O(1)`` 的，算是符合题目的要求。具体Python实现代码如下

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ptr1 = 0  # 标记已排序位置
        left = 0  # 窗口左指针
        right = 1  # 窗口右指针
        while right < len(nums):
            while right<len(nums) and nums[left] == nums[right]:
                right += 1
            if right - left > 1:
                nums[ptr1] = nums[left]
                nums[ptr1+1] = nums[left]
                ptr1 += 2
            else:
                nums[ptr1] = nums[left]
                ptr1 += 1
            left = right
            right += 1
        if nums[len(nums)-1] != nums[len(nums)-2]:
            nums[ptr1] = nums[len(nums)-1]
            ptr1 += 1
        return ptr1
```

在LeetCode上的提交结果如下

![](/img/in-post/leetcode/classical-150/80-res.png)

时间复杂度排名比较落后，看来还能削减一半

## 169. 多数元素

- Date: 2025-11-19
- Level: 简单

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**
```
输入：nums = [2,2,1,1,1,2,2]
输出：2
 ```

**提示：**
- n == nums.length
- 1 <= n <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9
- 输入保证数组中一定有一个多数元素。

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

### 我的解法

最简单的方法就是暴力方法，直接统计每个元素出现的个数，然后挑出多数元素。时间复杂度为 ``O(n)``，空间复杂度也是 ``O(n)``，代码如下

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        max_count = 0
        nums_count = {}
        for x in nums:
            if x in nums_count:
                nums_count[x] += 1
            else:
                nums_count[x] = 1
            if max_count < nums_count[x]:
                max_count = nums_count[x]
                if max_count >= (len(nums)+1)//2:
                    return x
        # 确定存在多数数的情况下，其实不会走到
        return 0
```

提交结果如下，排名确实不咋地

![](/img/in-post/leetcode/classical-150/169-res.png)

### 更优解法

更优的解法是基于一个发现：如果在数组的一个前缀中存在一个元素出现的次数占前缀的一半，那么数组剩余部分中的多数元素与整个数组的多数元素是相同的。这个可以通过比较简单的方法来证明。
基于这个发现，我们就可以实现一种空间复杂度更低的方法，时间复杂度也是 ``O(n)``，但是系数会低一些。

具体Python代码实现如下

```python
    def majorityElement0(self, nums: List[int]) -> int:
        label = nums[0]
        count = 1
        for i in range(1, len(nums)):
            if nums[i]==label:
                count += 1
            else:
                count -= 1
            if count == 0 :
                label = nums[i]
                count = 1
        return label
```

提交结果如下

![](/img/in-post/leetcode/classical-150/169-res-2.png)

## 189.轮转数组

- Date: 2025-11-20
- Level: 中等

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

**示例 1:**
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
 ```

**提示：**

- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1
- 0 <= k <= 10^5
 

**进阶：**

- 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

### 我的解法一

最容易想到的方法就是直接重新拼接一个数组，只是需要注意的是这道题要求对数组的原址进行修改，所以暴力的解法如下，时间复杂度为 ``O(n)``， 空间复杂度也是 ``O(n)``。

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n <= 1:
            return
        k = k % n
        if k == 0:
            return
        
        nums1 = nums[-k:]
        nums2 = nums[:-k]
        nums[:k] = nums1
        nums[k:] = nums2
        return 
```

提交结果如下

![](/img/in-post/leetcode/classical-150/189-res.png)

虽然时间复杂度在提交排名中最优，但这道题的考察点应该是对空间复杂度的优化上。

### 我的解法二

题目中提示我们能否想出一种空间复杂度为 ``O(1)`` 的方法，我们来尝试一下。可以观察一下轮转的规律，很容易得到一个基于元素当前位置去计算轮转后元素位置的计算公式。
$$
i' = (i+k) \text{mod} n
$$

其中，$ i $ 为元素在数组中当前的位置，$ k $ 为轮转步数， $ i' $ 为该数组轮转后的新位置， $ n $ 为数组长度。
通过观察可以发现，在整个数组完整轮转完之前，一个元素的轮转只会影响另一个尚未参加轮转的元素。基于此我们就可以通过一个跳跃遍历来完成对整个数组的更新，所需要的额外空间只是一个指针和一个记录当前值的缓存，空间复杂度为 ``O(1)``

**有Bug**

## 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。


**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 105
- 0 <= prices[i] <= 104

### 我的解法

首先容易想到的是填表的方法，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                matrix[i][j] = max(current, matrix[i][j-1], matrix[i+1][j])
        return matrix[0][n-1]
```
但在系统提交后显示内存超出限制，接下来需要对内存使用进行优化。上面这个代码的空间复杂度是 ``O(n^2)``的，实际上表（矩阵）中的每个元素我们只用了一次，所以可以继续优化，每次只保留当前步长，以及上一步长的结果，这样可以使空间复杂度降到 ``O(n)``，具体代码实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        profits = [0 for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                current_profit = max(profits[i], profits[i+1], current)
                profits[i] = current_profit
        return profits[0]
```

这次有时间超限制了，212个测试样例通过了198个。

### 官方题解

看了官方题解之后，是自己傻了，只需要遍历一次数组即可，时间复杂度 ``O(n)``，空间复杂度 ``O(1)``，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/121-res.png)

## 122. 买卖股票的最佳时机

- Date: 2025-11-22
- Level: 中等

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 你能获得的 最大 利润 。

 
**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 3 * 10^4
- 0 <= prices[i] <= 10^4

### 我的解法

利用动态规划解法，从第 i 天到第 j 天的最大收益为

$$
\text{profit}(i, j) = \text{max}(\text{profit}(i+1, j)+\text{profit}(i, j-1)-\text{profit}(i+1, j-1), \text{price}(j)-\text{price}(i))
$$

可以写出Python代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        n = len(prices)
        profits = [[0 for _ in range(n)] for __ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j >= n:
                    break
                profits[i][j] = max(profits[i][j-1]+profits[i+1][j]-profits[i+1][j-1], prices[j]-prices[i])
        return profits[0][n-1]      
```

提交后提示超出内存限制。其实不必保存整个利润数组

其实不必这么复杂，只要有利润就加进来即可，时间复杂度为 $ O(n) $，具体Python实现代码如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        profit = 0
        for i in range(0, len(prices)-1):
            profit += max(0, prices[i+1]-prices[i])
        return profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/122-res.png)

## 55. 跳跃游戏

- Date：2025-11-24
- Level: 中等

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
 ```

**提示：**

- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 10^5

### 我的解法

这道题最容易想到的做法就是用广度优先搜索或深度优先搜索，以下是使用广度优先搜索的Python实现

```python
from collections import deque
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        queue_list = deque()
        queue_list.append(0)
        
        while len(queue_list)>0:
            current = queue_list.popleft()
            if current == len(nums)-1:
                return True
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in queue_list)):
                    queue_list.append(current+i)
        if len(nums)-1 in arrived_pos:
            return True
        return False
```

但提交后显示运行超时。我们重新检查代码，感觉 ``((current+i) in queue_list)`` 这个在双向队列中判断元素是否存在的过程耗时较大，我们可以将其替换为hashset来节省时间，修改后的代码如下

```python

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        arriving_pos = set()
        arriving_pos.add(0)
        
        while len(arriving_pos)>0:
            current = arriving_pos.pop()
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in arriving_pos)):
                    if current + i == len(nums)-1:
                        return True
                    arriving_pos.add(current+i)
        return False

```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res.png)

这个方案的时间效率仍然是比较垫底的。

### 官方解法

看了官方解法之后感觉自己好蠢。这道题直接用贪心方法即可

对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。

Python 代码如下

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        
        max_pos = nums[0]
        if max_pos >= len(nums)-1:
            return True
        for i in range(0, len(nums)):
            if i > max_pos:
                return False
            max_pos = max(max_pos, i + nums[i])
            if max_pos >= len(nums)-1:
                return True

        return False
```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res2.png)

## 45. 跳跃游戏II

- Date： 2025-11-24
- Level: 中等

给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：

0 <= j <= nums[i] 且
i + j < n
返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。

 

**示例 1:**
```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**
```
输入: nums = [2,3,0,1,4]
输出: 2
 ```

**提示:**

- 1 <= nums.length <= 104
- 0 <= nums[i] <= 1000
- 题目保证可以到达 n - 1

### 我的解法

仍然可以用贪心的方法，计算每一步最远能走到哪里，只是需要注意一些边界判断的细节，Python代码实现如下

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums)==1:
            return 0
        if nums[0]>= len(nums)-1:
            return 1
        step = 1
        max_list = [0]
        max_list.append(nums[0])
        while True:
            max_list.append(0)
            for i in range(max_list[step-1], max_list[step]+1):
                max_list[step+1] = max(max_list[step+1], i+nums[i])
                if max_list[step+1]>=len(nums)-1:
                    return step+1
            step += 1
            if step > len(nums):
                return -1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/45-res.png)

## 274. H指数

- Date: 2025-11-24
- Level: 中等

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。

根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**示例 2：**
```
输入：citations = [1,3,1]
输出：1
 ```

**提示：**

- n == citations.length
- 1 <= n <= 5000
- 0 <= citations[i] <= 1000
 
### 我的解法

一种容易想到的方法就是先排序，将数组按照从小到大的顺序排好之后从左到右逐步判断，同时从 n 到 0 逐渐降低H指数。这样时间复杂度主要是在排序阶段，为 $ O(n\text{log}n) $，具体代码实现如下

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        self.quick_sort(citations)
        print('citations = ', citations)
        n = len(citations)
        for i in range(0, n):
            if citations[i]>=n-i:
                return n-i
        return 0

    def quick_sort(self, arr: List):
        if len(arr) <= 1:
            return
        self.quick_sort_partation(arr, 0, len(arr) - 1)

    def quick_sort_partation(self, arr: List[int], left: int, right: int):
        if right - left <= 0:
            return
        ptr1 = left - 1
        for ptr2 in range(left, right):
            if arr[ptr2] <= arr[right]:
                ptr1 += 1
                temp = arr[ptr1]
                arr[ptr1] = arr[ptr2]
                arr[ptr2] = temp
        temp = arr[ptr1 + 1]
        arr[ptr1 + 1] = arr[right]
        arr[right] = temp
        self.quick_sort_partation(arr, left, ptr1)
        self.quick_sort_partation(arr, ptr1 + 2, right)
```

提交结果如下

![](/img/in-post/leetcode/classical-150/274-res.png)

其实有时候不必手搓快排，看面试时要求即可，可以直接使用 ``sorted`` 方法。

## 238. 除自身以外的数组乘积

- Date: 2025-11-26
- Level: 中等

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

 
**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
 ```

**提示：**

- 2 <= nums.length <= 10^5
- -30 <= nums[i] <= 30
- 输入 保证 数组 answer[i] 在  32 位 整数范围内

### 解法

这道题的主要难点在于不能使用除法，一开始确实没有想到好的方法。直到看了官方的题解，大呼自己愚蠢。其实可以两次遍历数组即可，第一次计算每个位置的左侧所有元素的乘积，第二次计算每个位置右侧所有元素的乘积，然后二者相乘即可得到答案，时间复杂度为 ``O(n)``，Python代码实现如下

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        answer = [1]
        for i in range(1, len(nums)):
            answer.append(answer[-1]*nums[i-1])  # 计算左边的乘积
        right = 1
        for i in range(len(nums)-2, -1, -1):
            right *= nums[i+1]
            answer[i] *= right
        return answer
        
```

提交结果如下

![](/img/in-post/leetcode/classical-150/238-res.png)

## 134. 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
 ```

**提示:**

- n == gas.length == cost.length
- 1 <= n <= 10^5
- 0 <= gas[i], cost[i] <= 10^4
- 输入保证答案唯一。


### 我的解法

首先想到的是暴力解法，根据每个加油站的油量以及到达下一个加油站所需的油量，可以计算出从这个加油站出发到达下一个加油站的净油增量，我们只能从某个净油增量不为负的加油站出发。如此可以写出暴力的解法，时间复杂度为 ``O(n^2)``

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        res = []
        n = len(gas)
        for i in range(0, n):
            res.append(gas[i]-cost[i])
        for i in range(0, n):
            if res[i]>=0:
                s = 0
                flag = True
                for j in range(i, n):
                    s += res[j]
                    if s < 0:
                        flag = False
                        break
                if flag:
                    for j in range(0, j):
                        s += res[j]
                        if s < 0:
                            flag = False
                            break
                if flag:
                    return i
        return -1     
```
不出所料，运行超时

### 贪心解法

看了，网友的题解才明白这道题可以用贪心的方法来做：

x能到达y但不能到达y+1，实际上说明了：x与y之间的任意一个点（设为k）的不可能比x还“富裕”，因为x能到达k，则一定说明x到达k的时候一定油量是有余或者刚好的，不能是亏欠的；那么如果x都到达不了，“白手起家”的k就更不可能了。

这样就可以只遍历一次数组即可得到答案，总的时间复杂度为 O(n) 。Python代码如下

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        start = 0
        s = 0
        i = 0
        while i < start + n:
            if start >= n:
                return -1
            j = i % n
            s += gas[j] - cost[j]
            if s<0:
                start = i+1
                s = 0
            i += 1
            
        return start
```

提交结果如下

![](/img/in-post/leetcode/classical-150/134-res.png)


## 42. 接雨水

- Date: 2025-11-25
- Level: 困难

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](/img/in-post/leetcode/classical-150/42-question.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
 ```

**提示：**

- n == height.length
- 1 <= n <= 2 * 10^4
- 0 <= height[i] <= 10^5

### 我的解法

可以观察题目中给出的示意图，能盛水的凹槽一定会有两个边，左边的边和右边的边。这两个边一定是其所在局部的局部最高点，即左边所在位置向右移一步会降低，右边所在的位置向左移一步会降低。我们写一个函数分别找出数组的某个范围内左边第一个凹槽的左边和右边第一个凹槽的右边是比较容易的。找出这两个边之后，我们只需要判断哪个边矮，然后优先去处理哪个凹槽，更新剩余范围内的下一个边就可以了。这样总的时间复杂度就是 $ O(n) $ 的，因为只需要遍历一遍数组。具体Python代码实现如下

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n<=2:
            return 0
        total_water = 0

        # 从左边寻找第一个高点
        start_index = self.find_left_edge(height, 0, n-1)
        # 从右边寻找第一个高点
        end_index = self.find_right_edge(height, 0, n-1)
        if start_index==-1 or end_index==-1 or start_index >= end_index:
            return 0

        left = start_index
        right = end_index
        while left < right:
            if height[left] <= height[right]:
                # 先看左边的
                next_left_index = left + 1
                while next_left_index<=right and height[next_left_index]<height[left]:
                    total_water += height[left] - height[next_left_index]
                    next_left_index += 1
                left = self.find_left_edge(height, next_left_index, right)
                if left == -1:
                    break
            else:
                # 先看最右边的
                next_right_index = right - 1
                while next_right_index>=left and height[next_right_index]<height[right]:
                    total_water += height[right] - height[next_right_index]
                    next_right_index -= 1
                right = self.find_right_edge(height, left, next_right_index)
                if right == -1:
                    break
        return total_water

    # 在start_index到end_index范围内寻找能盛水的左边
    def find_left_edge(self, height: List[int], start_index, end_index):
        if start_index == end_index:
            return -1
        for i in range(start_index, end_index):
            if height[i] > height[i+1]:
                return i
        return -1

    # 在start_index到end_index的范围内从右到左寻找能盛水的右边
    def find_right_edge(self, height: List[int], start_index, end_index):
        if start_index == end_index:
            return -1
        for i in range(end_index, start_index, -1):
            if height[i] > height[i-1]:
                return i
        return -1

```

提交后的结果如下

![](/img/in-post/leetcode/classical-150/42-res.png)

## 13. 罗马数字转整数

- Level: 简单
- Date: 2025-11-26

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

 

**示例 1:**
```
输入: s = "III"
输出: 3
```

**示例 2:**

```
输入: s = "IV"
输出: 4
```

**示例 3:**
```
输入: s = "IX"
输出: 9
```

**示例 4:**

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
 ```

**提示：**

- 1 <= s.length <= 15
- s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
- 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 罗马数字 - 百度百科。


### 我的解法

直接按照问题描述来做，从左到右依次判断，时间复杂度为 $ O(n) $，Python代码实现如下

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        total_num = 0
        current_num = 0
        current_init = s[0]
        for i in range(0, len(s)):
            current_num += roman_dict[s[i]]
            if i == len(s)-1:
                total_num += current_num
            else:
                if roman_dict[s[i+1]]>roman_dict[s[i]]:
                    current_num *= -1
                    total_num += current_num
                    current_num = 0
                elif roman_dict[s[i+1]]<roman_dict[s[i]]:
                    total_num += current_num
                    current_num = 0
            
        return total_num
```

![](/img/in-post/leetcode/classical-150/13-res.png)

## 12. 整数转罗马数字

- Date: 2025-11-26
- Level: 中等

七个不同的符号代表罗马数字，其值如下：
```
符号	值
I	1
V	5
X	10
L	50
C	100
D	500
M	1000
```

罗马数字是通过添加从最高到最低的小数位值的转换而形成的。将小数位值转换为罗马数字有以下规则：

- 如果该值不是以 4 或 9 开头，请选择可以从输入中减去的最大值的符号，将该符号附加到结果，减去其值，然后将其余部分转换为罗马数字。
- 如果该值以 4 或 9 开头，使用 减法形式，表示从以下符号中减去一个符号，例如 4 是 5 (V) 减 1 (I): IV ，9 是 10 (X) 减 1 (I)：IX。仅使用以下减法形式：4 (IV)，9 (IX)，40 (XL)，90 (XC)，400 (CD) 和 900 (CM)。
- 只有 10 的次方（I, X, C, M）最多可以连续附加 3 次以代表 10 的倍数。你不能多次附加 5 (V)，50 (L) 或 500 (D)。如果需要将符号附加4次，请使用 减法形式。
  
给定一个整数，将其转换为罗马数字。

**示例 1：**

```
输入：num = 3749

输出： "MMMDCCXLIX"

解释：

3000 = MMM 由于 1000 (M) + 1000 (M) + 1000 (M)
 700 = DCC 由于 500 (D) + 100 (C) + 100 (C)
  40 = XL 由于 50 (L) 减 10 (X)
   9 = IX 由于 10 (X) 减 1 (I)
注意：49 不是 50 (L) 减 1 (I) 因为转换是基于小数位
```

**示例 2：**

```
输入：num = 58

输出："LVIII"

解释：

50 = L
 8 = VIII
```

**示例 3：**

```
输入：num = 1994

输出："MCMXCIV"

解释：

1000 = M
 900 = CM
  90 = XC
   4 = IV
``` 

**提示：**

- 1 <= num <= 3999
 
### 我的解法

这道题直接硬编码就行，没有达到中等的难度

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        if num == 0:
            return ''
        if num >= 1000:
            return 'M' + self.intToRoman(num-1000)
        elif num >= 500:
            if num>=900:
                return 'CM' + self.intToRoman(num-900)
            else:
                return 'D' + self.intToRoman(num-500)
        elif num >= 400:
            return 'CD' + self.intToRoman(num-400)
        elif num >= 100:
            return 'C' + self.intToRoman(num-100)
        elif num >= 90:
            return 'XC' + self.intToRoman(num-90)
        elif num >= 50:
            return 'L' + self.intToRoman(num-50)
        elif num >= 40:
            return 'XL' + self.intToRoman(num-40)
        elif num >= 10:
            return 'X' + self.intToRoman(num-10)
        elif num == 9:
            return 'IX'
        elif num >= 5:
            return 'V' + self.intToRoman(num-5)
        elif num == 4:
            return 'IV'
        else:
            return 'I' + self.intToRoman(num-1)
        
```

提交结果如下

![](/img/in-post/leetcode/classical-150/res-12.png)

速度没有达到最优，实际上还有通过剪枝减少递归次数的空间。

## 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。
```

**示例 2：**

```
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为 4。
```

**示例 3：**
```
输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为 6 的“joyboy”。
 ```

**提示：**

- 1 <= s.length <= 104
- s 仅有英文字母和空格 ' ' 组成
- s 中至少存在一个单词

### 生产环境解法

在实际生产环境中肯定会用 ``split`` 函数直接分割字符串，并从最后一个位置开始找第一个不全为空格的单词判断其长度返回。Python代码实现如下

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        items = s.split(' ')
        for i in range(0, len(items)):
            n = len(items[len(items)-i-1].replace(' ', ''))
            if n > 0:
                return n
```

提交结果如下

![](/img/in-post/leetcode/classical-150/58-res.png)


## 14. 最长公共前缀

- Level: 简单
- Date: 2025-11-26

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
 ```

**提示：**

- 1 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] 如果非空，则仅由小写英文字母组成

### 我的解法

直接遍历的暴力解法：

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) == 0:
            return ''
        long_prefix = ''
        shortest = 999  # 一个比较大的数
        for s in strs:
            if len(s) < shortest:
                shortest = len(s)
        for l in range(0, shortest):
            p = strs[0][l]
            flag = True
            for s in strs:
                if s[l] != p :
                    flag = False
                    break
            if flag:
                long_prefix = long_prefix + p 
            else:
                break
        return long_prefix 
```

提交结果为
![](/img/in-post/leetcode/classical-150/14-res.png)

## 151. 反转字符串中的单词

- Level：中等
- Date： 2025-11-28

给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
 ```

**提示：**

- 1 <= s.length <= 104
- s 包含英文大小写字母、数字和空格 ' '
- s 中 至少存在一个 单词
 
**进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。

### 我的解法

忽略掉进阶要求的话，这道题比较简单，Python实现如下

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        if len(s) == 0:
            return s 
        items = s.split(' ')
        s_list = []
        for i in range(len(items)-1, -1, -1):
            temp_s = items[i].replace(' ', '')
            if len(temp_s)>0:
                s_list.append(temp_s)
        return ' '.join(s_list)
```

提交结果如下

![](/img/in-post/leetcode/classical-150/151-res.png)

## 6. Z字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：
```
string convert(string s, int numRows);
 ```

**示例 1：**
```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**
```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**
```
输入：s = "A", numRows = 1
输出："A"
 ```

**提示：**

- 1 <= s.length <= 1000
- s 由英文字母（小写和大写）、',' 和 '.' 组成
- 1 <= numRows <= 1000

### 我的解法

可以总结出一套公式直接实现

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        max_step = (numRows-1) * 2
        res_str = ''
        for line_index in range(0, numRows):
            # print(f'=========== {line_index} ==========')
            ptr = line_index
            if ptr >= len(s):
                break
            # res_str = res_str + s[ptr]
            # 每套循环最多两步
            first_step = max_step - line_index * 2
            second_step = max_step - first_step
            res_str = res_str + s[ptr]
            while ptr < len(s):
                if first_step > 0:
                    ptr = ptr + first_step
                    if ptr >= len(s):
                        break
                    else:
                        res_str = res_str + s[ptr]
                if second_step > 0:
                    ptr = ptr + second_step
                    if ptr >= len(s):
                        break
                    else:
                        res_str = res_str + s[ptr]
        return res_str
```

提交结果如下

![](/img/in-post/leetcode/classical-150/6-res.png)

## 28. 找出字符串中第一个匹配项的下标

- Level: 简单
- Date：2025-12-01

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
 ```

**提示：**

- 1 <= haystack.length, needle.length <= 10^4
- haystack 和 needle 仅由小写英文字符组成

### 我的解法

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if len(haystack) < len(needle):
            return -1
        
        for i in range(0, len(haystack)-len(needle)+1):
            if haystack[i:len(needle)+i] == needle:
                return i 

        return -1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/28-res.png)

## 125. 验证回文串

- Level: 简单
- Date: 2025-12-01

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**
```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

**示例 3：**

```
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。
 ```

**提示：**

- 1 <= s.length <= 2 * 10^5
- s 仅由可打印的 ASCII 字符组成

### 我的解法

这道题比较简单，主要是要对使用的编程语言的一些字符类操作熟悉一些，有些语言可以用自带的大小写转换等，有些语言可以直接基于ASCII编码进行加减运算等。我的代码实现如下

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        if len(s) <= 1:
            return True
        s = s.lower()
        left = 0
        right = len(s)-1
        while left <= right:
            while not (s[left].isalpha() or s[left].isdigit()):
                left += 1
                if left >= len(s):
                    break
            while not (s[right].isalpha() or s[right].isdigit()):
                right -= 1
                if right < 0:
                    break
            if left >= right:
                return True
            
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1

        return True
```

提交结果如下

![](/img/in-post/leetcode/classical-150/125-res.png)

## 392.判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**致谢：**

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

 

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**
```
输入：s = "axc", t = "ahbgdc"
输出：false
 ```

**提示：**

- 0 <= s.length <= 100
- 0 <= t.length <= 10^4
- 两个字符串都只由小写字符组成。

### 我的解法

如果不考虑进阶要求，只需要在t中逐个搜索s中的字符即可，用Python实现如下

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if len(s)>len(t):
            return False

        ptr = 0
        for i in range(0, len(s)):
            while ptr<len(t) and s[i] != t[ptr]:
                ptr += 1
            if ptr == len(t):
                return False 
            ptr += 1
        return True
```

提交结果如下

![](/img/in-post/leetcode/classical-150/392-res.png)

## 167. 两数之和 II - 输入有序数组

- Date: 2025-12-01
- Level: 中等

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

 
**示例 1：**
```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**
```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

**示例 3：**
```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
 ```

**提示：**

- 2 <= numbers.length <= 3 * 10^4
- -1000 <= numbers[i] <= 1000
- numbers 按 非递减顺序 排列
- -1000 <= target <= 1000
- 仅存在一个有效答案

### 我的解法

可以设置左右两个指针来维护一个有效搜索区间，如果 $ \text{target} > \text{numbers}[\text{left}] + \text{numbers}[\text{right}] $ 则可以舍弃掉 $ \text{left} $ 左边的部分，$ \text{left} += 1 $， 如果 $ \text{target} < \text{numbers}[\text{left}] + \text{numbers}[\text{right}] $ 则可以舍弃掉 $ \text{right} $ 右边的部分，$ \text{right} += 1 $。这样算法的时间复杂度为 $ O(n) $ Python代码实现如下

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers)-1
        while right > left:
            temp = numbers[left] + numbers[right]
            if temp == target:
                return [left+1, right+1]
            elif temp < target:
                left += 1
            else:
                right -= 1
        return [-1, -1]
        
```

提交结果如下

![](/img/in-post/leetcode/classical-150/167-res.png)

时间复杂度并不是最优的，下一步或许可以思考能否结合二分法之类的方法进一步降低算法的时间复杂度。

## 11. 盛水最多的容器

- Date: 2025-12-01
- Level: 中等

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明**：你不能倾斜容器。

![](/img/in-post/leetcode/classical-150/11-title.png) 

**示例 1：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**
```
输入：height = [1,1]
输出：1
 ```

**提示：**

- n == height.length
- 2 <= n <= 10^5
- 0 <= height[i] <= 10^4

### 我的解法

想到一个时间复杂度为 $ O(n) $的方法，设置左右两个指针，哪个位置的高度低就将哪个指针向中间移动，过程中记录最大的容量，这样需要遍历一遍数组，所以时间复杂度为 $ O(n) $，用Python实现如下

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        if len(height) < 2:
            return 0
        left = 0
        right = len(height) - 1
        max_water = 0
        while left < right:
            max_water = max(max_water, min(height[left], height[right])*(right-left))
            if height[left]<=height[right]:
                left += 1
            else:
                right -= 1
        return max_water
        
```

提交结果如下

![](/img/in-post/leetcode//classical-150/11-res.png)

## 15. 三数之和

- Level: 中等
- Date: 2025-12-02

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
 
**示例 1：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**
```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**
```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
 ```

**提示：**

- 3 <= nums.length <= 3000
- -10^5 <= nums[i] <= 10^5

### 我的解法

最简单的是暴力方法，先固定住两个再去找第三个，为了加快搜索可以先对数据排序，然后用二分法搜索，这样总的时间复杂度为 $ O(n^2\text{log}n) $

用Python代码实现如下

```python

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        res = []  # 因为是排好序的，所以判重只需要跟最后一个比较就可以了
        res_set = set()
        for ptr1 in range(0, len(nums)-2):
            for ptr2 in range(ptr1+1, len(nums)-1):
                if len(res) > 0 and (f'{nums[ptr1]},{nums[ptr2]}') in res_set:  # 查重机制需要修改
                    continue
                temp = nums[ptr1] + nums[ptr2]
                target = 0 - temp
                ptr3 = self.findNum(nums, target, ptr2 + 1, len(nums)-1)
                if ptr3 > 0:
                    res.append([nums[ptr1], nums[ptr2], nums[ptr3]])
                    res_set.add(f'{nums[ptr1]},{nums[ptr2]}')
        return res

                
    def findNum(self, nums, target, start, end):
        # 在有序数组的start开始到end结尾的部分中找一个数，返回这个数的索引
        if start > end:
            return -1
        if target == nums[start]:
            return start 
        if target == nums[end]:
            return end 
        if target < nums[start]:
            return -1
        if target > nums[end]:
            return -2
        if end > start + 1:
            mid = (start + end) // 2
            if nums[mid] == target:
                return mid 
            elif target > nums[mid]:
                return self.findNum(nums, target, mid+1, end-1)
            else:
                return self.findNum(nums, target, start+1, mid-1)
        else:
            return -3

```

提交之后显示超时。

### 官方解法

官方解法也是先将数组排序，然后使用双指针的方法。另外为了实现判重，比较了双指针的新旧位置的值是否相同。整个代码的时间复杂度为 $O(n^2)$，Python代码实现如下

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        res = []  # 因为是排好序的，所以判重只需要跟最后一个比较就可以了

        for ptr1 in range(0, len(nums)-2):
            if ptr1 > 0 and nums[ptr1] == nums[ptr1-1]:
                continue
            if nums[ptr1] > 0:
                break
            ptr2 = ptr1 + 1
            ptr3 = len(nums) - 1
            while ptr2 < ptr3:
                if nums[ptr1] + nums[ptr2] > 0:
                    break
                temp = nums[ptr2] + nums[ptr3] + nums[ptr1]
                if temp == 0:
                    res.append([nums[ptr1], nums[ptr2], nums[ptr3]])
                    ptr2 += 1  # 需要防止死循环，继续搜索
                    while ptr2 < ptr3 and nums[ptr2]==nums[ptr2-1]:
                        ptr2 += 1
                elif temp > 0:
                    ptr3 -= 1
                    while ptr2 < ptr3 and nums[ptr3] == nums[ptr3+1]:
                        ptr3 -= 1
                else:
                    ptr2 += 1
                    while ptr2 < ptr3 and nums[ptr2] == nums[ptr2-1]:
                        ptr2 += 1
        return res


```

提交结果如下

![](/img/in-post/leetcode/classical-150/15-res.png)

