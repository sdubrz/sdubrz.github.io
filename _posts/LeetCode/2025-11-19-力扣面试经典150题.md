---
layout:       post
title:        "LeetCode面试经典150题刷题笔记"
date:         2025-11-19 14:08
author:       "rz"
header-style: text
catalog:      true
mathjax: true
tags:
    - LeetCode
    - Python
    - 数据结构
    - 算法
    - 面试
---

## 88.合并两个有序数组

- Date: 2025-11-19
- Level：简单

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 ```

**提示：**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9 <= nums1[i], nums2[j] <= 10^9
 

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

### 我的解法

这个题类似于数组的原址排序。所以主要思路分为先大后小排序还是先小后大排序。先小后大的话，会存在一个元素被多次重新防止的问题，而先大后小则不存在这个问题。

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        ptr1 = m-1
        ptr2 = n-1
        for i in range(m+n-1, -1, -1):
            if ptr1 < 0:
                nums1[i] = nums2[ptr2]
                ptr2 -= 1
            elif ptr2 < 0:
                break
            else:
                if nums1[ptr1]>=nums2[ptr2]:
                    nums1[i] = nums1[ptr1]
                    ptr1 -= 1
                else:
                    nums1[i] = nums2[ptr2]
                    ptr2 -= 1
```

提交结果如下。

![](/img/in-post/leetcode/classical-150/88-res.png)


## 27.移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。

假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
返回 k。
用户评测：

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 通过。

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```


**提示：**

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100

### 我的解法

是一个原址操作数组的问题，需要把值不等于val的放在前面，并统计个数，后面的结果不用管。也需要本着尽可能少地交换次数的原则，可以设置前后两个指针，分别从此前往后遍历和从后往前遍历，如果前面遇到值为val的元素就让它和后指针遇到的值不为val的元素交换（由于结果中不关心数组后面的部分，所以其实只需要将后指针的数复制到前指针的位置），直到两个指针碰头。
需要注意的是边界条件的设置，具体Python代码实现如下：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if len(nums)==0:
            return 0
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[left]==val:
                while right >= left:
                    if nums[right]==val:
                        right -= 1
                    else:
                        nums[left] = nums[right]
                        right -= 1
                        left += 1
                        break
            else:
                left += 1

        if left >= len(nums):
            return len(nums)
        return max(0, left)

```

提交结果如下

![](/img/in-post/leetcode/classical-150/27-res.png)

## 26. 删除有序数组中的重复项

- Date: 2025-11-19
- Level: 简单

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。

nums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。

判题标准:

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 通过。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 104
- -100 <= nums[i] <= 100
- nums 已按 非递减 顺序排列。

### 我的解法

这道题中已经说明要处理的数组是按照非递减顺序排好序的，也就是后一个元素肯定不小于前一个元素，并且要求处理后的数组前 k 个元素也是非递减顺序的，也就是递增的（因为已经去重）。这时候就不适合用两个指针分别从头到尾和从尾到头处理了。但也可以用两个指针来处理，一个慢指针和一个快指针。慢指针 ptr1 负责保证其之前的元素都是已经去重的，快指针负责寻找下一个未出现过的数。具体的Python实现代码如下：


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)<=1:
            return len(nums)
        ptr1 = 0
        ptr2 = 1
        while ptr2<len(nums):
            if nums[ptr1] <= nums[ptr2]:
                while ptr2<len(nums) and nums[ptr2]<=nums[ptr1]:
                    ptr2 += 1
                if ptr2 == len(nums):
                    return ptr1 + 1
                nums[ptr1+1] = nums[ptr2]
            ptr1 += 1
            ptr2 += 1
        return ptr1 + 1
```

提交结果如下

![](/img/in-post/leetcode/classical-150/26-res.png)

可以看到时间复杂度并不是最优的。这是因为题目里还有条件我们没有利用上。即数组元素的取值只有201个，但数组的长度却可能长达30000，其实只要慢指针到达了200之后，就不用继续往下判断了。为了更进一步，我们可以在外层的 while 循环中加上一个小的终止条件，在LeetCode中的时间复杂度就可以达到最优了。

```python
if ptr1 == 200:
    return 201
```

![](/img/in-post/leetcode/classical-150/26-res2.png)

## 80. 删除有序数组中的重复项II

- Date: 2025-11-19
- Level: 中等

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
 ```

**示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
 ```

**提示：**

- 1 <= nums.length <= 3 * 10^4
- -10^4 <= nums[i] <= 10^4
- nums 已按升序排列

### 我的解法

一种最容易想到的笨方法是搞三个指针，第一个指针标记当前已经处理好的符合题目要求的前缀长度，另外两个指针用来标记一个滑动窗口，根据滑动窗口的大小来确定前缀子数组需要增长1个还是2个。这种思路的时间复杂度为 ``O(n)``，空间复杂度主要是三个指针，以及一些循环变量，是 ``O(1)`` 的，算是符合题目的要求。具体Python实现代码如下

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ptr1 = 0  # 标记已排序位置
        left = 0  # 窗口左指针
        right = 1  # 窗口右指针
        while right < len(nums):
            while right<len(nums) and nums[left] == nums[right]:
                right += 1
            if right - left > 1:
                nums[ptr1] = nums[left]
                nums[ptr1+1] = nums[left]
                ptr1 += 2
            else:
                nums[ptr1] = nums[left]
                ptr1 += 1
            left = right
            right += 1
        if nums[len(nums)-1] != nums[len(nums)-2]:
            nums[ptr1] = nums[len(nums)-1]
            ptr1 += 1
        return ptr1
```

在LeetCode上的提交结果如下

![](/img/in-post/leetcode/classical-150/80-res.png)

时间复杂度排名比较落后，看来还能削减一半

## 169. 多数元素

- Date: 2025-11-19
- Level: 简单

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**
```
输入：nums = [2,2,1,1,1,2,2]
输出：2
 ```

**提示：**
- n == nums.length
- 1 <= n <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9
- 输入保证数组中一定有一个多数元素。

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

### 我的解法

最简单的方法就是暴力方法，直接统计每个元素出现的个数，然后挑出多数元素。时间复杂度为 ``O(n)``，空间复杂度也是 ``O(n)``，代码如下

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        max_count = 0
        nums_count = {}
        for x in nums:
            if x in nums_count:
                nums_count[x] += 1
            else:
                nums_count[x] = 1
            if max_count < nums_count[x]:
                max_count = nums_count[x]
                if max_count >= (len(nums)+1)//2:
                    return x
        # 确定存在多数数的情况下，其实不会走到
        return 0
```

提交结果如下，排名确实不咋地

![](/img/in-post/leetcode/classical-150/169-res.png)

### 更优解法

更优的解法是基于一个发现：如果在数组的一个前缀中存在一个元素出现的次数占前缀的一半，那么数组剩余部分中的多数元素与整个数组的多数元素是相同的。这个可以通过比较简单的方法来证明。
基于这个发现，我们就可以实现一种空间复杂度更低的方法，时间复杂度也是 ``O(n)``，但是系数会低一些。

具体Python代码实现如下

```python
    def majorityElement0(self, nums: List[int]) -> int:
        label = nums[0]
        count = 1
        for i in range(1, len(nums)):
            if nums[i]==label:
                count += 1
            else:
                count -= 1
            if count == 0 :
                label = nums[i]
                count = 1
        return label
```

提交结果如下

![](/img/in-post/leetcode/classical-150/169-res-2.png)

## 189.轮转数组

- Date: 2025-11-20
- Level: 中等

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

**示例 1:**
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
 ```

**提示：**

- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1
- 0 <= k <= 10^5
 

**进阶：**

- 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

### 我的解法一

最容易想到的方法就是直接重新拼接一个数组，只是需要注意的是这道题要求对数组的原址进行修改，所以暴力的解法如下，时间复杂度为 ``O(n)``， 空间复杂度也是 ``O(n)``。

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n <= 1:
            return
        k = k % n
        if k == 0:
            return
        
        nums1 = nums[-k:]
        nums2 = nums[:-k]
        nums[:k] = nums1
        nums[k:] = nums2
        return 
```

提交结果如下

![](/img/in-post/leetcode/classical-150/189-res.png)

虽然时间复杂度在提交排名中最优，但这道题的考察点应该是对空间复杂度的优化上。

### 我的解法二

题目中提示我们能否想出一种空间复杂度为 ``O(1)`` 的方法，我们来尝试一下。可以观察一下轮转的规律，很容易得到一个基于元素当前位置去计算轮转后元素位置的计算公式。
$$
i' = (i+k) \text{mod} n
$$

其中，$ i $ 为元素在数组中当前的位置，$ k $ 为轮转步数， $ i' $ 为该数组轮转后的新位置， $ n $ 为数组长度。
通过观察可以发现，在整个数组完整轮转完之前，一个元素的轮转只会影响另一个尚未参加轮转的元素。基于此我们就可以通过一个跳跃遍历来完成对整个数组的更新，所需要的额外空间只是一个指针和一个记录当前值的缓存，空间复杂度为 ``O(1)``

**有Bug**

## 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。


**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**
```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 105
- 0 <= prices[i] <= 104

### 我的解法

首先容易想到的是填表的方法，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                matrix[i][j] = max(current, matrix[i][j-1], matrix[i+1][j])
        return matrix[0][n-1]
```
但在系统提交后显示内存超出限制，接下来需要对内存使用进行优化。上面这个代码的空间复杂度是 ``O(n^2)``的，实际上表（矩阵）中的每个元素我们只用了一次，所以可以继续优化，每次只保留当前步长，以及上一步长的结果，这样可以使空间复杂度降到 ``O(n)``，具体代码实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        profits = [0 for _ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j > n-1:
                    break
                current = max(prices[j] - prices[i], 0)
                current_profit = max(profits[i], profits[i+1], current)
                profits[i] = current_profit
        return profits[0]
```

这次有时间超限制了，212个测试样例通过了198个。

### 官方题解

看了官方题解之后，是自己傻了，只需要遍历一次数组即可，时间复杂度 ``O(n)``，空间复杂度 ``O(1)``，具体实现如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            min_price = min(min_price, prices[i])
            max_profit = max(max_profit, prices[i]-min_price)
        return max_profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/121-res.png)

## 122. 买卖股票的最佳时机

- Date: 2025-11-22
- Level: 中等

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 你能获得的 最大 利润 。

 
**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
 ```

**提示：**

- 1 <= prices.length <= 3 * 10^4
- 0 <= prices[i] <= 10^4

### 我的解法

利用动态规划解法，从第 i 天到第 j 天的最大收益为

$$
\text{profit}(i, j) = \text{max}(\text{profit}(i+1, j)+\text{profit}(i, j-1)-\text{profit}(i+1, j-1), \text{price}(j)-\text{price}(i))
$$

可以写出Python代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        n = len(prices)
        profits = [[0 for _ in range(n)] for __ in range(n)]
        for step in range(1, n):
            for i in range(0, n-1):
                j = i + step
                if j >= n:
                    break
                profits[i][j] = max(profits[i][j-1]+profits[i+1][j]-profits[i+1][j-1], prices[j]-prices[i])
        return profits[0][n-1]      
```

提交后提示超出内存限制。其实不必保存整个利润数组

其实不必这么复杂，只要有利润就加进来即可，时间复杂度为 $ O(n) $，具体Python实现代码如下

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        profit = 0
        for i in range(0, len(prices)-1):
            profit += max(0, prices[i+1]-prices[i])
        return profit
```

提交结果如下

![](/img/in-post/leetcode/classical-150/122-res.png)

## 55. 跳跃游戏

- Date：2025-11-24
- Level: 中等

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
 ```

**提示：**

- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 10^5

### 我的解法

这道题最容易想到的做法就是用广度优先搜索或深度优先搜索，以下是使用广度优先搜索的Python实现

```python
from collections import deque
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        queue_list = deque()
        queue_list.append(0)
        
        while len(queue_list)>0:
            current = queue_list.popleft()
            if current == len(nums)-1:
                return True
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in queue_list)):
                    queue_list.append(current+i)
        if len(nums)-1 in arrived_pos:
            return True
        return False
```

但提交后显示运行超时。我们重新检查代码，感觉 ``((current+i) in queue_list)`` 这个在双向队列中判断元素是否存在的过程耗时较大，我们可以将其替换为hashset来节省时间，修改后的代码如下

```python

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        arrived_pos = set()
        arriving_pos = set()
        arriving_pos.add(0)
        
        while len(arriving_pos)>0:
            current = arriving_pos.pop()
            arrived_pos.add(current)
            for i in range(0, nums[current]+1):
                if not (((current + i) in arrived_pos) or ((current+i) in arriving_pos)):
                    if current + i == len(nums)-1:
                        return True
                    arriving_pos.add(current+i)
        return False

```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res.png)

这个方案的时间效率仍然是比较垫底的。

### 官方解法

看了官方解法之后感觉自己好蠢。这道题直接用贪心方法即可

对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。

Python 代码如下

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums)==0:
            return False
        if len(nums)==1:
            return True
        if nums[0] == 0:
            return False
        
        max_pos = nums[0]
        if max_pos >= len(nums)-1:
            return True
        for i in range(0, len(nums)):
            if i > max_pos:
                return False
            max_pos = max(max_pos, i + nums[i])
            if max_pos >= len(nums)-1:
                return True

        return False
```

提交结果如下

![](/img/in-post/leetcode/classical-150/55-res2.png)

## 45. 跳跃游戏II

- Date： 2025-11-24
- Level: 中等

给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：

0 <= j <= nums[i] 且
i + j < n
返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。

 

**示例 1:**
```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**
```
输入: nums = [2,3,0,1,4]
输出: 2
 ```

**提示:**

- 1 <= nums.length <= 104
- 0 <= nums[i] <= 1000
- 题目保证可以到达 n - 1

### 我的解法

感觉可以用动态规划

